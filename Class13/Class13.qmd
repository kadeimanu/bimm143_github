---
title: "Class 13"
author: "Kaliyah Adeimanu (A18125684)"
format: pdf
---

## Background 
Today we will perform an RNASeq analysis of the effects of a common sertoid on airways cells

In particular, dexamethasone (herafter just called "dex") on different airways smooth muscle cell lines (ASM cells).

## Data Import

We need two different inputs: 

- **countData**: with genes in rows and experiments in columns 
- **colData**:meta data that describes the columns in countData

```{r}
counts <- read.csv("airway_scaledcounts.csv",row.names=1)
metadata <- read.csv("airway_metadata.csv")
```

Have a look at counts and metadata
```{r}
head(counts)
```
```{r}
metadata
```
 
> Q1. How many genes are in this dataset? 

```{r}
nrow(counts)
```

> Q2. How many ‘control’ cell lines do we have?

```{r}
table(metadata$dex)
```
There are 4 control cell lines 


## Differential gene expression

We have four replicate treated and control (no drug) columns / experiments in out `counts`object.

We want one "mean" value for each gene (rows) in "treated" and one mean value for ecah gene in "control" columns. 


Step 1. Find all "control" columns in `counts` 
Step 2. extract these columns to a new object called `control.counts`
step 3. Then calculate the mean vlaue for each gene 

Step 1. 

```{r}
metadata$dex == "control"
```
Step 2. 

```{r}
metadata
```

```{r}
control.inds <- metadata$dex == "control"
```

```{r}
control.counts <- counts[, control.inds]
```

```{r}
head(control.counts)
```
Step 3. 

```{r}
control.mean<- rowMeans(control.counts)
```

```{r}
head(control.mean)
```
> Q3.How would you make the above code in either approach more robust? Is there a function that could help here?

Using `rowMeans()` is more effective then using row sums and manually calculating the mean using the number of rows.  

> Q4. Now do the smae thing for the "treated" columns/ experiments...


step 1. 
```{r}
metadata$dex == "treated"
```
step 2. 

```{r}
treated.inds <- metadata$dex == "treated"
```

```{r}
treated.counts <- counts[, treated.inds]
```
```{r}
head(treated.counts)
```
step 3. 

```{r}
treated.mean <- rowMeans(treated.counts)
```
```{r}
head(treated.mean)
```


Put these together for easy book-keeping as `meancounts`
```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

> Q5a. Create a scatter plot showing the mean of the treated samples against the mean of the control samples using base R

A quick plot 
```{r}
plot(meancounts)
```
> Q5b. Create a scatter plot showing the mean of the treated samples against the mean of the control samples using ggplot

```{r}
library(ggplot2)
ggplot(meancounts, aes(control.mean, treated.mean)) + geom_point()
```


>Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

`log` allows us to do this.  
Let's log transform this count data: 

```{r}
plot(control.mean, treated.mean, log="xy")
```

**N.B** We most often use log2 for this type of data as it makes the interpretation much more striaghtforward.

Treated/Control is often called "fold-change"

If there was no change we would have log2-fc of zero:
```{r}
log2(10/10)
```
If we had double of gene transcript we would have log2-fc of 1
```{r}
log2(20/10)
```
If we had half as much gene transcript we would have log2-fc of -1
```{r}
log2(5/10)
```

> Q. Calculate the log2 fold change value for all of our genes and add it as a new column to our `meancounts` object

```{r}
meancounts$log2fc <- log2(meancounts$treated.mean / meancounts$control.mean)
head(meancounts)
```

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

`arr.ind()` controls the format making it = TRUE means displays the matrix above. The first coloumn shows all the control means for each gene.   


```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

```{r}
sum(up.ind)
```
 250
 
> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

```{r}
sum(down.ind)
```
367 

>Q10. Do you trust these results? Why or why not?

Yes I trust these results it has summed up the total of values that are true meaning the values are greater than 2 or less than -2.  

## DESeq analysis 

Let's do this analysis with an estimate of statistical significance using the **DESeq2** package.  

```{r, message=FALSE}
library(DESeq2)
```


DESeq (like many bioconductor packages ) wants it's input data in a very specific way. 

```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                       colData=metadata, 
                       design = ~dex)
```

### Run the DESeq analysis pipeline

The main function `DESeq()`

```{r}
dds<- DESeq(dds)
```
```{r}
res <- results(dds)
head(res)
```

## Volcano Plot 

This is a main summary results figure from these kinds of studies.  It is a plot of Log2 Fold-change vs Adjusted P-value.  

```{r}
plot(res$log2FoldChange, 
     res$padj)
```


Again this y-axis is highly skewed, needs a log transformation and we can flip the y-axis with a minus sign so it looks like every other volcano plot. 

```{r}
plot(res$log2FoldChange,-log(res$padj))
abline(v=-2, col="red")
abline(v=+2, col="red")
abline(h= -log(0.05), col="red")
```

### Addding some color annotation

Start with a default base color "gray"
```{r}
mycols <- rep("gray", nrow(res))
mycols [res$log2FoldChange > 2 ] <- "blue"
mycols [res$log2FoldChange < -2 ] <- "darkgreen"
mycols [res$padj >= 0.05] <- "gray"

plot(res$log2FoldChange,
     -log(res$padj),
     col=mycols)
```



```{r}
# custom colors
mycols <- rep("gray", nrow(res))
mycols [res$log2FoldChange > 2 ] <- "blue"
mycols [res$log2FoldChange < -2 ] <- "darkgreen"
mycols [res$padj >= 0.05] <- "gray"

# Plot 
plot(res$log2FoldChange,
     -log(res$padj),
     col=mycols)

# Add some cut-off lines
abline(v= c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)


```
> Q. Make a presentation quality ggplot version of this plot, inclued clear axis labels, a clean theme, your custom colors, cut-off lines and a plot title. 

Now a ggplot version: 

```{r}
library(ggplot2)
ggplot(res, aes(log2FoldChange,
                -log(padj),))+
  geom_point(color= mycols)+
  labs(title="Upregualted and Downregulated Gene Volcano Plot", x="Log2 Fold-change", y="-log Adjusted P-Value") +
    geom_vline(xintercept = -2 , color = "red", linetype = "dashed", size = 1) +
  geom_hline(yintercept = (-log(0.05)), color = "red", linetype = "dotted", size = 1) +
  geom_vline(xintercept = 2 , color = "red", linetype = "dashed", size = 1)
  
```

## Save our results 

Write a CSV file 

```{r}
write.csv(res, file="results.csv")
```


## Add Annotation Data

We need to add missing annotation data to our main `res` results object.  This includes the common gene "symbol" 

```{r}
head(res)
```

We will use R and bioconductor to do this "ID mapping"

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

Lets see what databases we can use for translation/ mapping ...

```{r}
columns(org.Hs.eg.db)
```

We can use the `mapIds()` function now to "translate" between any of these databases.  

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",   # The format of our genenames
                     column="SYMBOL")     # The new format we want to add
```

> Q11. Also add "ENTREZID" , "GENENAME"

```{r}
res$entrezid <-mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",   # The format of our genenames
                     column="ENTREZID")     # The new format we want to add 

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",   # The format of our genenames
                     column="GENENAME")     # The new format we want to add
```


```{r}
head(res)
```

## Save annotated results to a CSV file

```{r}
write.csv(res, file="results_annotated.csv")
```

## Pathway analysis

What know biological pathways do our differentially expressed genes overlap with (i.e. play a role in)

There ar elots of bioconductor packages to do this type of analysis.  

We will use one of the oldest called **gage** along with the **pathview** to render nice pics of the pathways we find. 

We can install these with the command: 
`BiocManager::install( c("pathview", "gage", "gageData") )`

```{r, message=FALSE}
library(pathview)
library(gage)
library(gageData)
```


Have a wee peak what is in `gageData` 

```{r}
# Examine the first 2 pathways in this kegg set for humans
data(kegg.sets.hs)
head(kegg.sets.hs, 2)
```

The main `gage()` function that does the actual work wants a simple vector as input
The KEGG database uses ENTREZ is so we need to provide these in our input vector for **gage**
```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$entrezid
head(foldchanges)
```

Now we can run `gage()`

```{r}
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

What is the output object for `kegress`

```{r}
attributes(keggres)
```

```{r}
head(keggres$less,3)
```

We can use **pathview** function to render a figure of any of these pathways along with annotation for our DEGs,.

Let's see the hsa05310 Asthma pathway with our DEGS colored up. 

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```

![](hsa05310.pathview.png)

> Q12. Can you render and insert here the pathway figure for "Graft-versus-host disease" and "Type 1 diabetes"? 

Graft-verus-host
```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05332")
```
![](hsa05332.pathview.png)

Type 1 Diabetes

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa04940")
```
![](hsa04940.pathview.png)


